{"ast":null,"code":"function choose2(arr) {\n  if (arr.length === 2) {\n    return [arr[0] + arr[1]];\n  }\n\n  const slice = arr.slice(1);\n  return slice.map(x => x + arr[0]).concat(choose2(slice));\n}\n\nexport default function calculateHighOrLow(tb1, tb2, me) {\n  const tb1Err = tb1 && (tb1 === tb2 || tb1 === me);\n  const tb2Err = tb2 && (tb2 === tb1 || tb2 === me);\n  const meErr = me && (me === tb1 || me === tb2);\n\n  if (tb1Err || tb2Err || meErr) {\n    return {\n      err: 'DUPLICATE',\n      tb1Err,\n      tb2Err,\n      meErr\n    };\n  }\n\n  if (!tb1 || !tb2 || !me) {\n    return {\n      err: 'INCOMPLETE'\n    };\n  }\n\n  const hiddenCards = [];\n  Array(9).fill().forEach((_, index) => {\n    const card = index + 1;\n\n    if (card !== tb1 && card !== tb2 && card !== me) {\n      hiddenCards.push(card);\n    }\n  });\n  const tbPossibles = hiddenCards.map(card => tb1 + tb2 + card);\n  const mePossibles = choose2(hiddenCards).map(sum => me + sum);\n  let high = 0;\n  let low = 0;\n  let both = 0;\n\n  for (const me of mePossibles) {\n    for (const tb of tbPossibles) {\n      me > tb ? ++high : me < tb ? ++low : ++both;\n    }\n  }\n\n  return {\n    err: null,\n    high,\n    low,\n    both\n  };\n}","map":null,"metadata":{},"sourceType":"module"}