{"ast":null,"code":"export let Fruit;\n\n(function (Fruit) {\n  Fruit[Fruit[\"XelphatolApple\"] = 8157] = \"XelphatolApple\";\n  Fruit[Fruit[\"MamookPear\"] = 8158] = \"MamookPear\";\n  Fruit[Fruit[\"OGhomoroBerries\"] = 8159] = \"OGhomoroBerries\";\n  Fruit[Fruit[\"DomanPlum\"] = 8160] = \"DomanPlum\";\n  Fruit[Fruit[\"Valfruit\"] = 8161] = \"Valfruit\";\n  Fruit[Fruit[\"CieldalaesPineapple\"] = 8162] = \"CieldalaesPineapple\";\n})(Fruit || (Fruit = {}));\n\nconst fruitValues = {\n  [Fruit.XelphatolApple]: {\n    R: 5,\n    G: -5,\n    B: -5\n  },\n  [Fruit.MamookPear]: {\n    R: -5,\n    G: 5,\n    B: -5\n  },\n  [Fruit.OGhomoroBerries]: {\n    R: -5,\n    G: -5,\n    B: 5\n  },\n  [Fruit.DomanPlum]: {\n    R: -5,\n    G: 5,\n    B: 5\n  },\n  [Fruit.Valfruit]: {\n    R: 5,\n    G: -5,\n    B: 5\n  },\n  [Fruit.CieldalaesPineapple]: {\n    R: 5,\n    G: 5,\n    B: -5\n  }\n};\n\nfunction _pick(array, count) {\n  if (count === 1) {\n    return array.map(x => [x]);\n  } else {\n    return array.flatMap(x => _pick(array, count - 1).map(subPick => [x, ...subPick]));\n  }\n}\n\nfunction pick(array, count) {\n  return Array.from(Array(count)).flatMap((_, index) => _pick(array, index + 1));\n}\n\nfunction maximum(array, predicate) {\n  let maxVal = -Infinity;\n  let maxElem;\n\n  for (const elem of array) {\n    let val = predicate(elem);\n\n    if (val > maxVal) {\n      maxVal = val;\n      maxElem = elem;\n    }\n  }\n\n  return {\n    elem: maxElem,\n    val: maxVal\n  };\n}\n\nfunction calculateFruitsDistance(fromColor, toColor, lookahead = 1) {\n  const fruits = [];\n  let currentColor = fromColor;\n  let currentDistance = fromColor.distanceTo(toColor);\n\n  while (true) {\n    const best = maximum(pick(Object.keys(fruitValues).map(Number), lookahead), fruits => -fruits.reduce((acc, curr) => acc.add(fruitValues[curr]), currentColor).distanceTo(toColor));\n\n    if (-best.val >= currentDistance) {\n      return fruits;\n    } else {\n      fruits.push(best.elem[0]);\n      currentColor = currentColor.add(fruitValues[best.elem[0]]);\n      currentDistance = currentColor.distanceTo(toColor);\n    }\n  }\n}\n\nfunction calculateFruitsMatrix(fromColor, toColor) {\n  const difference = fromColor.differenceFrom(toColor);\n  const fR = -(difference.G + difference.B) / 10;\n  const fG = -(difference.R + difference.B) / 10;\n  const fB = -(difference.R + difference.G) / 10;\n  const fruitCounts = [[Fruit.XelphatolApple, fR > 0 ? Math.round(fR) : 0], [Fruit.MamookPear, fG > 0 ? Math.round(fG) : 0], [Fruit.OGhomoroBerries, fB > 0 ? Math.round(fB) : 0], [Fruit.Valfruit, fR < 0 ? Math.round(-fR) : 0], [Fruit.DomanPlum, fG < 0 ? Math.round(-fG) : 0], [Fruit.CieldalaesPineapple, fB < 0 ? Math.round(-fB) : 0]];\n  const fruits = [];\n  let currentColor = fromColor;\n\n  while (fruitCounts.reduce((acc, curr) => acc + curr[1], 0) > 0) {\n    const best = maximum(fruitCounts.filter(([, count]) => count > 0), ([fruit]) => {\n      const nextColor = currentColor.add(fruitValues[fruit]);\n      return -Math.max(...[nextColor.R, nextColor.G, nextColor.B].map(val => Math.abs(127.5 - val)));\n    });\n    fruits.push(best.elem[0]);\n    currentColor = currentColor.add(fruitValues[best.elem[0]]);\n    best.elem[1] -= 1;\n  }\n\n  return fruits;\n} // const fruits = calculateFruitsMatrix(stains[36].color, stains[1].color)\n// console.log(fruits)\n// console.log(cF(fruits))\n// function cF (a: Fruit[]) {\n//   return Object.values(Fruit).map(f => [f, a.filter(b => b === f).length])\n// }\n//\n// function play (startColor: Color, fruits: Fruit[]) {\n//   let c = startColor\n//   console.log(cF(fruits))\n//   console.log(c.toString())\n//   for (const fruit of fruits) {\n//     c = c.add(fruitValues[fruit])\n//     console.log(c.toString() + '   |', fruit)\n//   }\n// }\n//\n// const start = new Color(230, 230, 230)\n// const end = new Color(0, 0, 5)\n//\n// play(start, calculateFruitsMatrix(start, end))\n// play(start, calculateFruitsDistance(start, end, 1))\n// play(start, calculateFruitsDistance(start, end, 6))\n// const validColors = Object.values(stains).filter(x => x.id < 84).map(x => x.color)\n//\n// let min = Infinity\n// let foo = null\n//\n// for (let i = 0; i < validColors.length; ++i) {\n//   console.log(i)\n//   for (let j = i + 1; j < validColors.length; ++j) {\n//     const d = validColors[i].distanceTo(validColors[j])\n//     if (d < min) {\n//       min = d\n//       foo = [validColors[i], validColors[j]]\n//     }\n//   }\n// }\n//\n// console.log(min, foo)\n\n\nfunction applyFruits(color, fruits) {\n  return fruits.reduce;\n} // const CURRANT_PURPLE = stains[79]\n// const GRAPE_PURPLE = stains[81]\n//\n// for (const stain of Object.values(stains)) {\n//   // console.log(`${stain.name_en} -> ${CURRANT_PURPLE.name_en}`)\n//   const fruits = calculateFruitsDistance(stain.color, CURRANT_PURPLE.color, 3)\n//   const result = fruits.reduce((color, fruit) => color.add(fruitValues[fruit]), stain.color)\n//   const closestMatch = maximum(Object.values(stains), stain => -stain.color.distanceTo(result))\n//   console.log(`${stain.name_en} -> ${closestMatch.elem.name_en}`)\n// }","map":null,"metadata":{},"sourceType":"module"}