{"ast":null,"code":"import { Color, Shade } from './data';\nimport en from './locales/en.json';\nimport de from './locales/de.json';\nimport fr from './locales/fr.json';\nimport ja from './locales/ja.json';\nconst LOCALES = {\n  en,\n  de,\n  fr,\n  ja\n};\nexport { Color, Shade };\nexport let Fruit;\n\n(function (Fruit) {\n  Fruit[Fruit[\"XelphatolApple\"] = 8157] = \"XelphatolApple\";\n  Fruit[Fruit[\"MamookPear\"] = 8158] = \"MamookPear\";\n  Fruit[Fruit[\"OGhomoroBerries\"] = 8159] = \"OGhomoroBerries\";\n  Fruit[Fruit[\"DomanPlum\"] = 8160] = \"DomanPlum\";\n  Fruit[Fruit[\"Valfruit\"] = 8161] = \"Valfruit\";\n  Fruit[Fruit[\"CieldalaesPineapple\"] = 8162] = \"CieldalaesPineapple\";\n})(Fruit || (Fruit = {}));\n\nexport const fruitValues = {\n  [Fruit.XelphatolApple]: {\n    R: 5,\n    G: -5,\n    B: -5\n  },\n  [Fruit.MamookPear]: {\n    R: -5,\n    G: 5,\n    B: -5\n  },\n  [Fruit.OGhomoroBerries]: {\n    R: -5,\n    G: -5,\n    B: 5\n  },\n  [Fruit.DomanPlum]: {\n    R: -5,\n    G: 5,\n    B: 5\n  },\n  [Fruit.Valfruit]: {\n    R: 5,\n    G: -5,\n    B: 5\n  },\n  [Fruit.CieldalaesPineapple]: {\n    R: 5,\n    G: 5,\n    B: -5\n  }\n};\n\nfunction _pick(array, count) {\n  if (count === 1) {\n    return array.map(x => [x]);\n  } else {\n    return array.flatMap(x => _pick(array, count - 1).map(subPick => [x, ...subPick]));\n  }\n}\n\nfunction pick(array, count) {\n  return Array.from(Array(count)).flatMap((_, index) => _pick(array, index + 1));\n}\n\nfunction maximum(array, predicate) {\n  let maxVal = -Infinity;\n  let maxElem;\n\n  for (const elem of array) {\n    let val = predicate(elem);\n\n    if (val > maxVal) {\n      maxVal = val;\n      maxElem = elem;\n    }\n  }\n\n  return {\n    elem: maxElem,\n    val: maxVal\n  };\n}\n\nexport function isValidStain(stain) {\n  return stain.shade >= 2 && stain.shade <= 9 && stain.id <= 85;\n}\nexport function calculateFruitsDistance(fromColor, toColor, lookahead = 1) {\n  const fruits = [];\n  let currentColor = fromColor;\n  let currentDistance = fromColor.distanceTo(toColor);\n\n  while (true) {\n    const best = maximum(pick(Object.keys(fruitValues).map(Number), lookahead), fruits => -fruits.reduce((acc, curr) => acc.add(fruitValues[curr]), currentColor).distanceTo(toColor));\n\n    if (-best.val >= currentDistance) {\n      return {\n        fruits,\n        color: currentColor,\n        distance: currentDistance\n      };\n    } else {\n      fruits.push(best.elem[0]);\n      currentColor = currentColor.add(fruitValues[best.elem[0]]);\n      currentDistance = currentColor.distanceTo(toColor);\n    }\n  }\n}\nexport function calculateFruitsMatrix(fromColor, toColor) {\n  const difference = fromColor.differenceFrom(toColor);\n  const fR = -(difference.G + difference.B) / 10;\n  const fG = -(difference.R + difference.B) / 10;\n  const fB = -(difference.R + difference.G) / 10;\n  const fruitCounts = [[Fruit.XelphatolApple, fR > 0 ? Math.round(fR) : 0], [Fruit.MamookPear, fG > 0 ? Math.round(fG) : 0], [Fruit.OGhomoroBerries, fB > 0 ? Math.round(fB) : 0], [Fruit.Valfruit, fR < 0 ? Math.round(-fR) : 0], [Fruit.DomanPlum, fG < 0 ? Math.round(-fG) : 0], [Fruit.CieldalaesPineapple, fB < 0 ? Math.round(-fB) : 0]];\n  const fruits = [];\n  let currentColor = fromColor;\n\n  while (fruitCounts.reduce((acc, curr) => acc + curr[1], 0) > 0) {\n    const best = maximum(fruitCounts.filter(([, count]) => count > 0), ([fruit]) => {\n      const nextColor = currentColor.add(fruitValues[fruit]);\n      return -Math.max(...[nextColor.R, nextColor.G, nextColor.B].map(val => Math.abs(127.5 - val)));\n    });\n    fruits.push(best.elem[0]);\n    currentColor = currentColor.add(fruitValues[best.elem[0]]);\n    best.elem[1] -= 1;\n  }\n\n  return {\n    fruits,\n    color: currentColor,\n    distance: currentColor.distanceTo(toColor)\n  };\n}\nexport function translate(type, id, locale = 'en') {\n  return LOCALES[locale] && LOCALES[locale][type][id] || `{${type}.${id}}`;\n}","map":null,"metadata":{},"sourceType":"module"}