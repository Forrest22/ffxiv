{"ast":null,"code":"import { timeUntil as genericTimeUntil } from '../utils';\nimport { fishingSpots, oceanFishes } from './ffxiv-ocean-fishing/data';\nimport { getStops } from './ffxiv-ocean-fishing';\nimport * as maps from './maps';\n\nfunction memoize(func) {\n  const cache = {};\n  return arg => {\n    const key = String(arg);\n    return cache[key] !== undefined ? cache[key] : cache[key] = func(arg);\n  };\n}\n\nexport function timeUntil(now, then, options) {\n  const diff = then.getTime() - now.getTime();\n\n  if (diff < -900000) {\n    return options.t('routeInfo.enRoute');\n  } else if (diff < 0) {\n    return options.t('routeInfo.boardingNow');\n  } else {\n    return genericTimeUntil(now, then, {\n      full: options.full,\n      locale: options.locale\n    });\n  }\n}\nexport function getTimeSensitiveFish(destinationCode) {\n  const stopTimes = getStops(destinationCode);\n  return stopTimes.map((destinationStopTime, index) => {\n    const fishingSpotId = maps.STOP_MAP[destinationStopTime[0]];\n    const time = stopTimes[index][1];\n    return fishingSpots[fishingSpotId + 1].fishes.filter(fishId => {\n      const spreadsheetData = oceanFishes[fishId].spreadsheetData;\n      return spreadsheetData.time && spreadsheetData.time.length !== 3 && spreadsheetData.time.includes(time);\n    });\n  });\n}\nexport function getPointsFish(destinationCode) {\n  const stopTimes = getStops(destinationCode);\n  return stopTimes.map((destinationStopTime, index) => {\n    const fishingSpotId = maps.STOP_MAP[destinationStopTime[0]];\n    const time = stopTimes[index][1];\n    let highestPointsFish = [];\n    const pointsFish = fishingSpots[fishingSpotId + 1].fishes.filter(fishId => {\n      const spreadsheetData = oceanFishes[fishId].spreadsheetData;\n\n      if (spreadsheetData.time && !spreadsheetData.time.includes(time)) {\n        return false;\n      } else if (spreadsheetData.intuition) {\n        return false;\n      } else if (!spreadsheetData.points || !spreadsheetData.doubleHook) {\n        return false;\n      } else {\n        const points = (Array.isArray(spreadsheetData.doubleHook) ? spreadsheetData.doubleHook[1] : spreadsheetData.doubleHook) * spreadsheetData.points;\n\n        if (highestPointsFish.length === 0) {\n          highestPointsFish.push({\n            fishId,\n            points\n          });\n        } else if (points === highestPointsFish[0].points) {\n          highestPointsFish.push({\n            fishId,\n            points\n          });\n        } else if (points > highestPointsFish[0].points) {\n          highestPointsFish = [{\n            fishId,\n            points\n          }];\n        }\n\n        return points >= 400;\n      }\n    });\n    return pointsFish.length > 0 ? pointsFish : highestPointsFish.map(({\n      fishId\n    }) => fishId);\n  });\n}\nexport function getBlueFish(destinationCode) {\n  const stopTimes = getStops(destinationCode);\n  return stopTimes.map(destinationStopTime => maps.BLUE_FISH_MAP[destinationStopTime[0]]).map((fishId, index) => {\n    const time = stopTimes[index][1];\n    const spreadsheetData = oceanFishes[fishId].spreadsheetData;\n    return spreadsheetData.time && spreadsheetData.time.includes(time) ? fishId : null;\n  });\n}\nexport function isBaitRequired(fishId, baitId) {\n  for (const otherBaitId of Object.keys(oceanFishes[fishId].biteTimes)) {\n    if (otherBaitId === 'all' || Number(otherBaitId) === baitId || Number(otherBaitId) === 29717) {\n      continue;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport const getBaitChain = memoize(function _getBaitChain(fishId) {\n  const spreadsheetData = oceanFishes[fishId].spreadsheetData;\n\n  if (!spreadsheetData.bait && !spreadsheetData.mooch) {\n    return [{\n      id: 29717\n    }, {\n      id: fishId,\n      tug: spreadsheetData.tug\n    }]; // Versatile Lure as fallback\n  } else {\n    return spreadsheetData.bait ? [{\n      id: spreadsheetData.bait\n    }, {\n      id: fishId,\n      tug: spreadsheetData.tug\n    }] : [..._getBaitChain(spreadsheetData.mooch), {\n      id: fishId,\n      tug: spreadsheetData.tug\n    }];\n  }\n});\nexport const getBaitGroup = memoize(fishId => {\n  const spreadsheetData = oceanFishes[fishId].spreadsheetData;\n  const baitChain = getBaitChain(fishId);\n  return {\n    baits: baitChain,\n    baitIsRequired: isBaitRequired(fishId, baitChain[0].id),\n    intuitionFishes: spreadsheetData.intuition && spreadsheetData.intuition.map(({\n      fishId,\n      count\n    }) => {\n      const baitChain = getBaitChain(fishId);\n      return {\n        baits: baitChain,\n        baitIsRequired: isBaitRequired(fishId, baitChain[0].id),\n        count\n      };\n    })\n  };\n});\nexport function subtextDH(fishId) {\n  const doubleHook = oceanFishes[fishId].spreadsheetData.doubleHook;\n  return doubleHook ? `DH: ${Array.isArray(doubleHook) ? doubleHook.join('-') : doubleHook}` : 'DH: ?';\n}\nexport function subtextBiteTime(fishId) {\n  const biteTimeAll = oceanFishes[fishId].biteTimes.all;\n  return biteTimeAll ? `${biteTimeAll[0] === biteTimeAll[1] ? biteTimeAll[0] : biteTimeAll.join('-')}s` : '?s';\n}\nexport function upperFirst(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\nexport function getBlindDHRanges(fishId, baitId, time) {\n  const spreadsheetData = oceanFishes[fishId].spreadsheetData;\n  if (time && spreadsheetData.time && spreadsheetData.time.indexOf(time) === -1) return null;\n  if (!oceanFishes[fishId].biteTimes[baitId]) return null;\n  const blindDHRanges = [oceanFishes[fishId].biteTimes[baitId]];\n  const fishingSpot = Object.values(fishingSpots).find(fishingSpot => fishingSpot.fishes.includes(fishId));\n\n  for (const otherFishId of fishingSpot.fishes) {\n    if (otherFishId === fishId) continue;\n    const otherSpreadsheetData = oceanFishes[otherFishId].spreadsheetData;\n    if (otherSpreadsheetData.tug !== spreadsheetData.tug) continue;\n    if (time && otherSpreadsheetData.time && otherSpreadsheetData.time.indexOf(time) === -1) continue;\n    if (!oceanFishes[otherFishId].biteTimes[baitId]) continue;\n    const otherRange = oceanFishes[otherFishId].biteTimes[baitId];\n\n    for (let i = 0; i < blindDHRanges.length;) {\n      const currentRange = blindDHRanges[i];\n\n      if (otherRange[1] < currentRange[0] || otherRange[0] > currentRange[1]) {\n        // No overlap\n        ++i;\n      } else if (otherRange[0] <= currentRange[0] && otherRange[1] >= currentRange[1]) {\n        // Full overlap\n        blindDHRanges.splice(i, 1);\n      } else if (otherRange[0] > currentRange[0] && otherRange[1] < currentRange[1]) {\n        // Splits currentRange into 2\n        blindDHRanges.splice(i, 1, [currentRange[0], otherRange[0] - 1], [otherRange[1] + 1, currentRange[1]]);\n        i += 2;\n      } else {\n        // Partial overlap\n        if (currentRange[0] < otherRange[0] && otherRange[0] < currentRange[1]) {\n          blindDHRanges.splice(i++, 1, [currentRange[0], otherRange[0] - 1]);\n        } else if (currentRange[0] < otherRange[1] && otherRange[1] < currentRange[1]) {\n          blindDHRanges.splice(i++, 1, [otherRange[1] + 1, currentRange[1]]);\n        } else {\n          console.error('This should never happen');\n          i++;\n        }\n      }\n    }\n  }\n\n  return blindDHRanges;\n}","map":null,"metadata":{},"sourceType":"module"}