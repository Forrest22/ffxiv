{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { timeUntil as genericTimeUntil } from '../utils';\nimport { fishingSpots, oceanFishes } from './ocean-fishing/data';\nimport { getStops } from './ocean-fishing';\nimport * as maps from './maps';\n\nfunction memoize(func) {\n  var cache = {};\n  return function (arg) {\n    var key = String(arg);\n    return cache[key] !== undefined ? cache[key] : cache[key] = func(arg);\n  };\n}\n\nexport function timeUntil(now, then, options) {\n  var diff = then.getTime() - now.getTime();\n\n  if (diff < -900000) {\n    return options.t('routeInfo.enRoute');\n  } else if (diff < 0) {\n    return options.t('routeInfo.boardingNow');\n  } else {\n    return genericTimeUntil(now, then, {\n      full: options.full,\n      locale: options.locale\n    });\n  }\n}\nexport function getTimeSensitiveFish(destinationCode) {\n  var stopTimes = getStops(destinationCode);\n  return stopTimes.map(function (destinationStopTime, index) {\n    var fishingSpotId = maps.STOP_MAP[destinationStopTime[0]];\n    var time = stopTimes[index][1];\n    return fishingSpots[fishingSpotId + 1].fishes.filter(function (fishId) {\n      var spreadsheetData = oceanFishes[fishId].spreadsheetData;\n      return spreadsheetData.time && spreadsheetData.time.length !== 3 && spreadsheetData.time.includes(time);\n    });\n  });\n}\nexport function getPointsFish(destinationCode) {\n  var stopTimes = getStops(destinationCode);\n  return stopTimes.map(function (destinationStopTime, index) {\n    var fishingSpotId = maps.STOP_MAP[destinationStopTime[0]];\n    var time = stopTimes[index][1];\n    var highestPointsFish = [];\n    var pointsFish = fishingSpots[fishingSpotId + 1].fishes.filter(function (fishId) {\n      var spreadsheetData = oceanFishes[fishId].spreadsheetData;\n\n      if (spreadsheetData.time && !spreadsheetData.time.includes(time)) {\n        return false;\n      } else if (spreadsheetData.intuition) {\n        return false;\n      } else if (!spreadsheetData.points || !spreadsheetData.doubleHook) {\n        return false;\n      } else {\n        var points = (Array.isArray(spreadsheetData.doubleHook) ? spreadsheetData.doubleHook[1] : spreadsheetData.doubleHook) * spreadsheetData.points;\n\n        if (highestPointsFish.length === 0) {\n          highestPointsFish.push({\n            fishId: fishId,\n            points: points\n          });\n        } else if (points === highestPointsFish[0].points) {\n          highestPointsFish.push({\n            fishId: fishId,\n            points: points\n          });\n        } else if (points > highestPointsFish[0].points) {\n          highestPointsFish = [{\n            fishId: fishId,\n            points: points\n          }];\n        }\n\n        return points >= 400;\n      }\n    });\n    return pointsFish.length > 0 ? pointsFish : highestPointsFish.map(function (_ref) {\n      var fishId = _ref.fishId;\n      return fishId;\n    });\n  });\n}\nexport function getBlueFish(destinationCode) {\n  var stopTimes = getStops(destinationCode);\n  return stopTimes.map(function (destinationStopTime) {\n    return maps.BLUE_FISH_MAP[destinationStopTime[0]];\n  }).map(function (fishId, index) {\n    var time = stopTimes[index][1];\n    var spreadsheetData = oceanFishes[fishId].spreadsheetData;\n    return spreadsheetData.time && spreadsheetData.time.includes(time) ? fishId : null;\n  });\n}\nexport var getBaitChain = memoize(function _getBaitChain(fishId) {\n  var spreadsheetData = oceanFishes[fishId].spreadsheetData;\n\n  if (!spreadsheetData.bait && !spreadsheetData.mooch) {\n    return [{\n      id: 29717\n    }, {\n      id: fishId,\n      tug: spreadsheetData.tug\n    }]; // Versatile Lure as fallback\n  } else {\n    return spreadsheetData.bait ? [{\n      id: spreadsheetData.bait\n    }, {\n      id: fishId,\n      tug: spreadsheetData.tug\n    }] : [].concat(_toConsumableArray(_getBaitChain(spreadsheetData.mooch)), [{\n      id: fishId,\n      tug: spreadsheetData.tug\n    }]);\n  }\n});\nexport var getBaitGroup = memoize(function (fishId) {\n  var spreadsheetData = oceanFishes[fishId].spreadsheetData;\n  return {\n    baits: getBaitChain(fishId),\n    intuitionFishes: spreadsheetData.intuition && spreadsheetData.intuition.map(function (_ref2) {\n      var fishId = _ref2.fishId,\n          count = _ref2.count;\n      return {\n        baits: getBaitChain(fishId),\n        count: count\n      };\n    })\n  };\n});\nexport function subtextDH(fishId) {\n  var doubleHook = oceanFishes[fishId].spreadsheetData.doubleHook;\n  return doubleHook ? \"DH: \".concat(Array.isArray(doubleHook) ? doubleHook.join('-') : doubleHook) : 'DH: ?';\n}\nexport function subtextBiteTime(fishId) {\n  var biteTimeAll = oceanFishes[fishId].biteTimes.all;\n  return biteTimeAll ? \"\".concat(biteTimeAll[0] === biteTimeAll[1] ? biteTimeAll[0] : biteTimeAll.join('-'), \"s\") : '?s';\n}\nexport function translate() {\n  var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';\n  var obj = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (!obj) {\n    return \"{\".concat(JSON.stringify(obj), \"}\");\n  }\n\n  for (var _len = arguments.length, keys = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    keys[_key - 2] = arguments[_key];\n  }\n\n  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n    var _key2 = _keys[_i];\n    var keyLocale = \"\".concat(_key2, \"_\").concat(locale);\n    if (obj[keyLocale]) return obj[keyLocale];\n  }\n\n  return \"{[Object].\".concat(keys.join(','), \"}\");\n}\nexport function upperFirst(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\nexport function getBlindDHRanges(fishId, baitId, time) {\n  var spreadsheetData = oceanFishes[fishId].spreadsheetData;\n  if (time && spreadsheetData.time && spreadsheetData.time.indexOf(time) === -1) return null;\n  if (!oceanFishes[fishId].biteTimes[baitId]) return null;\n  var blindDHRanges = [oceanFishes[fishId].biteTimes[baitId]];\n  var fishingSpot = Object.values(fishingSpots).find(function (fishingSpot) {\n    return fishingSpot.fishes.includes(fishId);\n  });\n\n  var _iterator = _createForOfIteratorHelper(fishingSpot.fishes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var otherFishId = _step.value;\n      if (otherFishId === fishId) continue;\n      var otherSpreadsheetData = oceanFishes[otherFishId].spreadsheetData;\n      if (otherSpreadsheetData.tug !== spreadsheetData.tug) continue;\n      if (time && otherSpreadsheetData.time && otherSpreadsheetData.time.indexOf(time) === -1) continue;\n      if (!oceanFishes[otherFishId].biteTimes[baitId]) continue;\n      var otherRange = oceanFishes[otherFishId].biteTimes[baitId];\n\n      for (var i = 0; i < blindDHRanges.length;) {\n        var currentRange = blindDHRanges[i];\n\n        if (otherRange[1] < currentRange[0] || otherRange[0] > currentRange[1]) {\n          // No overlap\n          ++i;\n        } else if (otherRange[0] <= currentRange[0] && otherRange[1] >= currentRange[1]) {\n          // Full overlap\n          blindDHRanges.splice(i, 1);\n        } else if (otherRange[0] > currentRange[0] && otherRange[1] < currentRange[1]) {\n          // Splits currentRange into 2\n          blindDHRanges.splice(i, 1, [currentRange[0], otherRange[0] - 1], [otherRange[1] + 1, currentRange[1]]);\n          i += 2;\n        } else {\n          // Partial overlap\n          if (currentRange[0] < otherRange[0] && otherRange[0] < currentRange[1]) {\n            blindDHRanges.splice(i++, 1, [currentRange[0], otherRange[0] - 1]);\n          } else if (currentRange[0] < otherRange[1] && otherRange[1] < currentRange[1]) {\n            blindDHRanges.splice(i++, 1, [otherRange[1] + 1, currentRange[1]]);\n          } else {\n            console.error('This should never happen');\n            i++;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return blindDHRanges;\n}","map":null,"metadata":{},"sourceType":"module"}