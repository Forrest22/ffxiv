{"ast":null,"code":"import moment from 'moment'; // Cycle repeats every 6 days; subtract time to make sure we're in the future\n\nexport var LULU_EPOCH = moment('2020-06-28 00:00+09:00').subtract(666, 'days');\nvar DEST_CYCLE = ['N', 'R'];\nvar TIME_CYCLE = ['D', 'S', 'N'];\n\nfunction calculateVoyages(time, count, filter) {\n  // Important that `time` is UTC+09:00\n  var day = time.diff(LULU_EPOCH, 'days');\n  var hour = time.hour(); // Adjust time to fall on the next voyage, including any ongoing\n\n  if (time.minute() < 45) hour -= 1;\n  hour += hour & 1 ? 2 : 1;\n\n  if (hour === 0) {\n    day -= 1;\n    hour = 24;\n  } else if (hour === 25) {\n    day += 1;\n    hour = 1;\n  } // Find the current voyage\n\n\n  var voyageNumber = hour >> 1;\n  var destIndex = (day + voyageNumber) % 2;\n  var timeIndex = ((day >> 1) + (voyageNumber >> 1)) % 3; // Loop until however many voyages are found\n\n  var upcomingVoyages = [];\n\n  while (upcomingVoyages.length < count) {\n    var destinationCode = DEST_CYCLE[destIndex] + TIME_CYCLE[timeIndex];\n\n    if (!filter || filter.includes(destinationCode)) {\n      upcomingVoyages.push({\n        day: day,\n        hour: hour,\n        destinationCode: destinationCode\n      });\n    }\n\n    if (hour === 23) {\n      day += 1;\n      hour = 1;\n      timeIndex = (timeIndex + (day & 1 ? 1 : 2)) % 3; // Time shifts every other day\n    } else {\n      hour += 2;\n      destIndex = (destIndex + 1) % 2;\n      timeIndex = (timeIndex + (hour >> 1 & 1 ? 0 : 1)) % 3;\n    }\n  }\n\n  return upcomingVoyages;\n}\n\nexport default calculateVoyages;","map":null,"metadata":{},"sourceType":"module"}