{"ast":null,"code":"const LINES = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [0, 4, 8, 12], [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [0, 5, 10, 15], [3, 6, 9, 12]];\n\nfunction countLines(board) {\n  let count = 0;\n\n  for (const line of LINES) {\n    if (board[line[0]] && board[line[1]] && board[line[2]] && board[line[3]]) {\n      ++count;\n    }\n  }\n\n  return count;\n}\n\nfunction choose(set, count) {\n  if (count >= set.length) {\n    return [set.slice()];\n  } else if (count === 0) {\n    return [[]];\n  } else {\n    return [...choose(set.slice(1), count - 1).map(x => [set[0], ...x]), ...choose(set.slice(1), count)];\n  }\n}\n\nfunction calculateProbabilities(board) {\n  const emptyIndices = Array(16).fill(undefined).map((_, index) => index).filter(index => !board[index]);\n  const possibleBoards = choose(emptyIndices, Math.max(emptyIndices.length - 7, 0)).map(empties => {\n    const newBoard = board.slice();\n\n    for (const index of empties) {\n      newBoard[index] = true;\n    }\n\n    return newBoard;\n  });\n  const buckets = [0, 0, 0, 0];\n\n  for (const possibleBoard of possibleBoards) {\n    ++buckets[Math.min(countLines(possibleBoard), 3)];\n  }\n\n  return {\n    lines1: buckets[1] + buckets[2] + buckets[3],\n    lines2: buckets[2] + buckets[3],\n    lines3: buckets[3],\n    total: possibleBoards.length\n  };\n}\n\nexport default calculateProbabilities;","map":null,"metadata":{},"sourceType":"module"}