{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useState } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { LINES, validateGrid, getSuggestion } from './calculate-mini-cactpot';\nimport Typography from '@material-ui/core/Typography';\nimport Grid from '@material-ui/core/Grid';\nimport Button from '@material-ui/core/Button';\nimport MiniCactpotCell from './MiniCactpotCell';\nconst useStyles = makeStyles(theme => ({\n  gridShrink: {\n    textAlign: 'center',\n    [theme.breakpoints.up('md')]: {\n      flex: '0 0 auto'\n    }\n  },\n  gridGrow: {\n    [theme.breakpoints.up('md')]: {\n      flex: '1 1 0px'\n    }\n  },\n  cellsContainer: {\n    display: 'inline-block',\n    border: theme.palette.type === 'dark' ? '1px solid gray' : '1px solid black'\n  }\n}));\nexport default function MiniCactpotCalculator(props) {\n  const {\n    0: grid,\n    1: setGrid\n  } = useState(Array(9).fill(null));\n  const classes = useStyles();\n\n  const handleInputDigit = (cellIndex, digit) => {\n    const newGrid = grid.slice();\n    newGrid[cellIndex] = digit;\n    setGrid(newGrid);\n  };\n\n  const handleClickReset = event => {\n    setGrid(Array(9).fill(null));\n  };\n\n  const error = validateGrid(grid);\n  const errorCells = {};\n\n  if (error) {\n    switch (error.type) {\n      case 'TOO MANY':\n      case 'DUPLICATES':\n        for (const cellIndex of error.cells) {\n          errorCells[cellIndex] = true;\n        }\n\n        break;\n    }\n  }\n\n  const suggestion = !error && getSuggestion(grid);\n  const suggestedCells = {};\n\n  if (suggestion) {\n    switch (suggestion.type) {\n      case 'CELL':\n        for (const cellIndex of suggestion.maxCellLocations) {\n          suggestedCells[cellIndex] = true;\n        }\n\n        break;\n\n      case 'LINE':\n        for (const lineId of suggestion.maxLineIds) {\n          for (const cellIndex of LINES[lineId]) {\n            suggestedCells[cellIndex] = true;\n          }\n        }\n\n    }\n  }\n\n  return __jsx(\"section\", null, __jsx(Grid, {\n    container: true,\n    spacing: 4\n  }, __jsx(Grid, {\n    item: true,\n    xs: 12,\n    className: classes.gridShrink\n  }, __jsx(\"div\", {\n    className: classes.cellsContainer\n  }, [0, 1, 2, null, 3, 4, 5, null, 6, 7, 8].map((cellIndex, index) => cellIndex !== null ? __jsx(MiniCactpotCell, {\n    key: index,\n    value: grid[cellIndex],\n    suggested: suggestedCells[cellIndex],\n    error: errorCells[cellIndex],\n    onInputDigit: handleInputDigit.bind(null, cellIndex)\n  }) : __jsx(\"br\", {\n    key: index\n  })))), __jsx(Grid, {\n    item: true,\n    xs: 12,\n    className: classes.gridGrow\n  }, (() => {\n    if (error) {\n      switch (error.type) {\n        case 'EMPTY':\n          return __jsx(Typography, {\n            paragraph: true\n          }, \"Click on a square to enter a digit.\");\n\n        case 'TOO MANY':\n          return __jsx(Typography, {\n            paragraph: true\n          }, \"Too many cells have been filled!\");\n\n        case 'DUPLICATES':\n          return __jsx(Typography, {\n            paragraph: true\n          }, \"Cells cannot repeat digits!\");\n      }\n    } else {\n      switch (suggestion.type) {\n        case 'CELL':\n          return __jsx(React.Fragment, null, __jsx(Typography, null, __jsx(\"b\", null, \"Expected value:\"), \" \", suggestion.maxCellEV | 0), __jsx(Typography, {\n            paragraph: true\n          }, \"Reveal a highlighted square.\"));\n\n        case 'LINE':\n          return __jsx(React.Fragment, null, __jsx(Typography, null, __jsx(\"b\", null, \"Expected value:\"), \" \", suggestion.maxLineEV | 0), __jsx(Typography, {\n            paragraph: true\n          }, \"Select a highlighted line!\"));\n      }\n    }\n  })(), __jsx(Button, {\n    variant: \"contained\",\n    color: \"secondary\",\n    onClick: handleClickReset\n  }, \"Reset\"))));\n}","map":null,"metadata":{},"sourceType":"module"}