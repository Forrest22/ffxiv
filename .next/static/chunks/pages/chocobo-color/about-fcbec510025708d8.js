(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[632],{7922:function(e,t,n){"use strict";n.d(t,{Z:function(){return X}});var r=n(3366),o=n(7462),i=n(7294),a=n(6010),l=n(8885),c=n(7192),s=n(1496),h=n(7623),d=n(6067),Z=n(577),u=n(2734),g=n(1705),p=n(8979);function m(e){return(0,p.Z)("MuiCollapse",e)}(0,n(6087).Z)("MuiCollapse",["root","horizontal","vertical","entered","hidden","wrapper","wrapperInner"]);var f=n(5893);const b=["addEndListener","children","className","collapsedSize","component","easing","in","onEnter","onEntered","onEntering","onExit","onExited","onExiting","orientation","style","timeout","TransitionComponent"],w=(0,s.ZP)("div",{name:"MuiCollapse",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.orientation],"entered"===n.state&&t.entered,"exited"===n.state&&!n.in&&"0px"===n.collapsedSize&&t.hidden]}})((({theme:e,ownerState:t})=>(0,o.Z)({height:0,overflow:"hidden",transition:e.transitions.create("height")},"horizontal"===t.orientation&&{height:"auto",width:0,transition:e.transitions.create("width")},"entered"===t.state&&(0,o.Z)({height:"auto",overflow:"visible"},"horizontal"===t.orientation&&{width:"auto"}),"exited"===t.state&&!t.in&&"0px"===t.collapsedSize&&{visibility:"hidden"}))),$=(0,s.ZP)("div",{name:"MuiCollapse",slot:"Wrapper",overridesResolver:(e,t)=>t.wrapper})((({ownerState:e})=>(0,o.Z)({display:"flex",width:"100%"},"horizontal"===e.orientation&&{width:"auto",height:"100%"}))),x=(0,s.ZP)("div",{name:"MuiCollapse",slot:"WrapperInner",overridesResolver:(e,t)=>t.wrapperInner})((({ownerState:e})=>(0,o.Z)({width:"100%"},"horizontal"===e.orientation&&{width:"auto",height:"100%"}))),v=i.forwardRef((function(e,t){const n=(0,h.Z)({props:e,name:"MuiCollapse"}),{addEndListener:s,children:p,className:v,collapsedSize:X="0px",component:B,easing:C,in:y,onEnter:k,onEntered:D,onEntering:P,onExit:T,onExited:O,onExiting:R,orientation:E="vertical",style:S,timeout:G=d.x9.standard,TransitionComponent:F=l.ZP}=n,I=(0,r.Z)(n,b),M=(0,o.Z)({},n,{orientation:E,collapsedSize:X}),A=(e=>{const{orientation:t,classes:n}=e,r={root:["root",`${t}`],entered:["entered"],hidden:["hidden"],wrapper:["wrapper",`${t}`],wrapperInner:["wrapperInner",`${t}`]};return(0,c.Z)(r,m,n)})(M),N=(0,u.Z)(),_=i.useRef(),z=i.useRef(null),q=i.useRef(),L="number"===typeof X?`${X}px`:X,V="horizontal"===E,W=V?"width":"height";i.useEffect((()=>()=>{clearTimeout(_.current)}),[]);const j=i.useRef(null),H=(0,g.Z)(t,j),U=e=>t=>{if(e){const n=j.current;void 0===t?e(n):e(n,t)}},J=()=>z.current?z.current[V?"clientWidth":"clientHeight"]:0,Q=U(((e,t)=>{z.current&&V&&(z.current.style.position="absolute"),e.style[W]=L,k&&k(e,t)})),Y=U(((e,t)=>{const n=J();z.current&&V&&(z.current.style.position="");const{duration:r,easing:o}=(0,Z.C)({style:S,timeout:G,easing:C},{mode:"enter"});if("auto"===G){const t=N.transitions.getAutoHeightDuration(n);e.style.transitionDuration=`${t}ms`,q.current=t}else e.style.transitionDuration="string"===typeof r?r:`${r}ms`;e.style[W]=`${n}px`,e.style.transitionTimingFunction=o,P&&P(e,t)})),K=U(((e,t)=>{e.style[W]="auto",D&&D(e,t)})),ee=U((e=>{e.style[W]=`${J()}px`,T&&T(e)})),te=U(O),ne=U((e=>{const t=J(),{duration:n,easing:r}=(0,Z.C)({style:S,timeout:G,easing:C},{mode:"exit"});if("auto"===G){const n=N.transitions.getAutoHeightDuration(t);e.style.transitionDuration=`${n}ms`,q.current=n}else e.style.transitionDuration="string"===typeof n?n:`${n}ms`;e.style[W]=L,e.style.transitionTimingFunction=r,R&&R(e)}));return(0,f.jsx)(F,(0,o.Z)({in:y,onEnter:Q,onEntered:K,onEntering:Y,onExit:ee,onExited:te,onExiting:ne,addEndListener:e=>{"auto"===G&&(_.current=setTimeout(e,q.current||0)),s&&s(j.current,e)},nodeRef:j,timeout:"auto"===G?null:G},I,{children:(e,t)=>(0,f.jsx)(w,(0,o.Z)({as:B,className:(0,a.Z)(A.root,v,{entered:A.entered,exited:!y&&"0px"===L&&A.hidden}[e]),style:(0,o.Z)({[V?"minWidth":"minHeight"]:L},S),ownerState:(0,o.Z)({},M,{state:e}),ref:H},t,{children:(0,f.jsx)($,{ownerState:(0,o.Z)({},M,{state:e}),className:A.wrapper,ref:z,children:(0,f.jsx)(x,{ownerState:(0,o.Z)({},M,{state:e}),className:A.wrapperInner,children:p})})}))}))}));v.muiSupportAuto=!0;var X=v},7238:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/chocobo-color/about",function(){return n(4813)}])},4813:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return S}});var r=n(5944),o=n(7294),i=n(1983),a=n(1796),l=n(5861),c=n(7357),s=n(5113),h=n(7922),d=n(2882),Z=n(7906),u=n(3184),g=n(295),p=n(3816),m=n(3252),f=n(1057),b=n(6906),w=n(8884),$=n(7255),x=n(7556),v=n(3432),X=n(5648),B=n(9371),C=n(3905),y=n(1921),k=n(9465),D=[8161,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157,8161,8159,8157],P=[8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8157,8159,8159,8159,8159,8159,8161,8159,8161,8159,8161,8159,8161,8159,8161,8159,8161,8159,8161,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8159,8161,8157,8161,8161,8161,8161,8161],T=function(e){return(0,a.Fq)(e.palette.success.main,.2)},O=function(e){return(0,a.Fq)(e.palette.error.main,.2)};function R(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"en";return e>=0?"+"+e.toLocaleString(t):e.toLocaleString(t)}var E=function(){var e=(0,o.useState)(!1),t=e[0],n=e[1];return(0,r.BX)(c.Z,{mb:2,children:[(0,r.BX)(f.Z,{variant:"contained",onClick:function(){n(!t)},children:[t?"Hide":"Show"," Solutions"]}),(0,r.tZ)(h.Z,{in:t,children:(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,r.BX)(s.Z,{component:Z.Z,sx:{width:"auto",m:"auto","& td":{py:0}},children:[(0,r.tZ)(u.Z,{children:(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{colSpan:5,align:"center",children:"Without clamping"}),(0,r.tZ)(m.Z,{colSpan:5,align:"center",children:"With clamping"})]})}),(0,r.tZ)(g.Z,{children:function(){var e=[],t=Math.max(D.length,P.length),n=C.DX[1].color,o=C.DX[1].color;e.push((0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{}),(0,r.tZ)(m.Z,{children:(0,v.$)("".concat(n.R))}),(0,r.tZ)(m.Z,{children:(0,v.$)("".concat(n.G))}),(0,r.tZ)(m.Z,{children:(0,v.$)("".concat(n.B))}),(0,r.tZ)(m.Z,{children:(0,r.tZ)(B.Z,{color:n})}),(0,r.tZ)(m.Z,{}),(0,r.tZ)(m.Z,{children:(0,v.$)("".concat(o.R))}),(0,r.tZ)(m.Z,{children:(0,v.$)("".concat(o.G))}),(0,r.tZ)(m.Z,{children:(0,v.$)("".concat(o.B))}),(0,r.tZ)(m.Z,{children:(0,r.tZ)(B.Z,{color:o})})]},-1));for(var i=0;i<t;++i){var a=D[i],l=P[i];void 0!==a&&(n=n.add(y.$x[a])),void 0!==l&&(o=o.add(y.$x[l])),e.push((0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{align:"center",children:void 0!==a&&(0,r.tZ)(X.Z,{fruit:a,size:.8,sx:{verticalAlign:"middle"}})}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==a&&(0,v.$)("".concat(n.R))}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==a&&(0,v.$)("".concat(n.G))}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==a&&(0,v.$)("".concat(n.B))}),(0,r.tZ)(m.Z,{children:void 0!==a&&(0,r.tZ)(B.Z,{color:n})}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==l&&(0,r.tZ)(X.Z,{fruit:l,size:.8,sx:{verticalAlign:"middle"}})}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==l&&(0,v.$)("".concat(o.R))}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==l&&(0,v.$)("".concat(o.G))}),(0,r.tZ)(m.Z,{align:"center",children:void 0!==l&&(0,v.$)("".concat(o.B))}),(0,r.tZ)(m.Z,{children:void 0!==l&&(0,r.tZ)(B.Z,{color:o})})]},i))}return e}()})]})})})]})},S=!0;t.default=function(){var e=(0,i.$G)("chocobo-color"),t=e.t,n=e.i18n.language;return(0,r.BX)(b.Z,{title:[t("_title"),t("aboutPage._title")],children:[(0,r.BX)(w.Z,{children:[(0,r.tZ)(l.Z,{paragraph:!0,children:"Your chocobo\u2019s plumage can be modified by feeding it 6 possible fruits. Each fruit changes the chocobo\u2019s RGB values according to the following table:"}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,r.BX)(s.Z,{component:Z.Z,sx:{width:"auto",m:"auto"},children:[(0,r.tZ)(u.Z,{children:(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{align:"center",children:"Fruit"}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("\\text{R}")}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("\\text{G}")}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("\\text{B}")})]})}),(0,r.tZ)(g.Z,{children:[y.PO.XelphatolApple,y.PO.MamookPear,y.PO.OGhomoroBerries,y.PO.DomanPlum,y.PO.Valfruit,y.PO.CieldalaesPineapple].map((function(e){var t=y.$x[e],o=t.R,i=t.G,a=t.B;return(0,r.BX)(p.Z,{children:[(0,r.BX)(m.Z,{children:[(0,r.tZ)(X.Z,{fruit:e,sx:{verticalAlign:"middle",mr:1}}),(0,r.tZ)(l.Z,{component:"span",sx:{verticalAlign:"middle"},children:(0,k.Z)(n,C.DN[e],"name")})]}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:o>0?T:o<0?O:"none"},children:(0,v.$)(R(o))}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:i>0?T:i<0?O:"none"},children:(0,v.$)(R(i))}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:a>0?T:a<0?O:"none"},children:(0,v.$)(R(a))})]},e)}))})]})}),(0,r.BX)(l.Z,{children:["RGB values can never exceed ",(0,v.$)("250")," or go below ",(0,v.$)("0"),". If eating a fruit will cause a value to go beyond the valid range, it will be clamped. The RGB values of possible colors are known, and the problem is how to determine what sequence of fruits will get from one color to another. Unfortunately, not all RGB values are possible since the fruits always change values in increments of ",(0,v.$)("5")," (ignoring clamping). The goal is to reach certain RGB values such that the closest possible color is the desired color. Distance here is measured using the ",(0,r.tZ)($.C,{href:"https://en.wikipedia.org/wiki/Euclidean_distance",children:"Euclidean norm"})," (assuming this is what FFXIV uses)."]}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,v.$$)("\\lVert \\text{Color} \\rVert = \\sqrt{\\text{Color.R}^2 + \\text{Color.G}^2 + \\text{Color.B}^2}")})]}),(0,r.BX)(w.Z,{title:"Greedy Algorithm",children:[(0,r.tZ)(l.Z,{paragraph:!0,children:"A simple algorithm is to keep picking the fruit that gets us closest to the desired color, stopping when no single fruit can get any closer."}),(0,r.tZ)(x.Z,{language:"typescript",sx:{mb:2},children:"\nfunction calculate (startColor: Color, endColor: Color): Fruit[] {\n  const solution: Fruit[] = []\n  let currentColor = startColor\n  let currentDistance = startColor.distanceTo(endColor)\n\n  while (true) {\n    // Find the best fruit\n    const fruitsSorted = fruits.sort((fruitA, fruitB) =>\n      currentColor.add(fruitA).distanceTo(endColor) -\n      currentColor.add(fruitB).distanceTo(endColor)\n    )\n    const bestFruit = fruitsSorted[0]\n\n    // If this fruit doesn't get us closer, stop\n    if (currentColor.add(bestFruit).distanceTo(endColor) >= currentDistance) {\n      return fruits\n\n    // Otherwise, add it to the list and continue\n    } else {\n      fruits.push(bestFruit)\n      currentColor = currentColor.add(bestFruit)\n      currentDistance = currentColor.distanceTo(endColor)\n    }\n  }\n}\n          ".trim()}),(0,r.BX)(l.Z,{paragraph:!0,children:["This algorithm has several shortcomings, but performs decently well and serves as the basis to the actual algorithm used. The biggest issue is that the algorithm tends to stop early. Suppose the target color is ",(0,v.$)("\\operatorname{RGB}(100, 100, 100)"),", and the current color is ",(0,v.$)("\\operatorname{RGB}(105, 105, 105)"),". The current distance is ",(0,v.$)("\\sqrt{75}")," and eating any fruit will cause this distance to jump up to ",(0,v.$)("\\sqrt{100}")," or ",(0,v.$)("\\sqrt{200}"),", so the algorithm terminates. But feeding the 3 fruits ",(0,k.Z)(n,C.DN[y.PO.XelphatolApple],"name"),", ",(0,k.Z)(n,C.DN[y.PO.MamookPear],"name"),", and ",(0,k.Z)(n,C.DN[y.PO.OGhomoroBerries],"name")," would land exactly on the target color."]})]}),(0,r.BX)(w.Z,{title:"Matrix Algorithm",children:[(0,r.tZ)(l.Z,{children:"The next algorithm to consider involves treating the problem as a sort of matrix equation. Using the variables"}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,v.$$)("\n            \\begin{align}\n              X & = \\text{# of ".concat((0,k.Z)(n,C.DN[y.PO.XelphatolApple],"plural","singular"),"} \\\\\n              M & = \\text{# of ").concat((0,k.Z)(n,C.DN[y.PO.MamookPear],"plural","singular"),"} \\\\\n              O & = \\text{# of ").concat((0,k.Z)(n,C.DN[y.PO.OGhomoroBerries],"plural","singular"),"} \\\\\n              D & = \\text{# of ").concat((0,k.Z)(n,C.DN[y.PO.DomanPlum],"plural","singular"),"} \\\\\n              V & = \\text{# of ").concat((0,k.Z)(n,C.DN[y.PO.Valfruit],"plural","singular"),"} \\\\\n              C & = \\text{# of ").concat((0,k.Z)(n,C.DN[y.PO.CieldalaesPineapple],"plural","singular"),"} \\\\\n            \\end{align}\n          "))}),(0,r.tZ)(l.Z,{children:"and not requiring them to be integers, we must solve"}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,v.$$)("\n            \\begin{array}{ll}\n              \\text{minimize}   & \\phantom{+}X +M +O +D +V +C, \\\\\n              \\\\\n              \\text{subject to} & +X -M -O -D +V +C = R / 5, \\\\\n                                 & -X +M -O +D -V +C = G / 5, \\\\\n                                 & -X -M +O +D +V -C = B / 5, \\\\\n              \\\\\n              \\text{and}        & X, M, O, D, V, C \\geq 0 \\\\\n            \\end{array}\n          ")}),(0,r.BX)(l.Z,{paragraph:!0,children:["where ",(0,v.$)("R, G, B")," is the difference ",(0,v.$)("\\text{DesiredColor} - \\text{CurrentColor}"),". This does not take into account clamping, which can be avoided almost always. It gives only the number of fruits required, which is then ordered to hopefully avoid clamping. I did this by repeatedly picking fruits that minimize the distance to ",(0,v.$)("\\operatorname{RGB}(\\frac{256}{2}, \\frac{256}{2}, \\frac{256}{2})")," using the ",(0,r.tZ)($.C,{href:"https://en.wikipedia.org/wiki/Uniform_norm",children:"uniform norm"}),"."]}),(0,r.BX)(l.Z,{children:["Since the ",(0,v.$)("D, V, C")," fruits are \u201copposites\u201d of the ",(0,v.$)("X, M, O")," fruits, we can drop the ",(0,v.$)("D, V, C")," variables by removing the nonnegativity constraints on ",(0,v.$)("X, M, O"),". This transforms the problem into the standard linear equation"]}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,v.$$)("\n            \\begin{pmatrix}\n              \\phantom{+}5 &            -5 &             -5 \\\\\n                         -5 & \\phantom{+}5 &             -5 \\\\\n                         -5 &            -5 &  \\phantom{+}5 \\\\\n            \\end{pmatrix}\n            \\begin{pmatrix}\n              X \\\\ M \\\\ O\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n              R \\\\ G \\\\ B\n            \\end{pmatrix}\n          ")}),(0,r.BX)(l.Z,{paragraph:!0,children:["with a negative value of ",(0,v.$)("X")," corresponding instead to a positive value of ",(0,v.$)("D"),", etc. To turn the solutions into integers, I round them. (This doesn\u2019t always give the closest color, and that problem is the ",(0,r.tZ)($.C,{href:"https://en.wikipedia.org/wiki/Lattice_problem#Closest_vector_problem_(CVP)",children:"closest vector problem"}),". The lattice is \u201cnice\u201d enough though, and since I don\u2019t end up using this strategy, I don\u2019t bother optimizing it.) This algorithm can outperform the first algorithm in situations where the first algorithm would terminate early."]})]}),(0,r.BX)(w.Z,{title:"Lookahead",children:[(0,r.tZ)(l.Z,{paragraph:!0,children:"To fix the issue of early termination in the first algorithm, some amount of lookahead is introduced. Instead of considering fruits one by one, the algorithm does the following:"}),(0,r.BX)("ol",{children:[(0,r.BX)(l.Z,{component:"li",children:["Compute all possible fruit combinations up to a length of ",(0,v.$)("L")]}),(0,r.BX)(l.Z,{component:"li",children:["Let ",(0,v.$)("F")," be the fruit combination that lands closest to the target color"]}),(0,r.BX)(l.Z,{component:"li",children:["If ",(0,v.$)("F")," contains no fruits, then stop (no path gets closer)"]}),(0,r.BX)(l.Z,{component:"li",children:["Otherwise, add the first fruit in ",(0,v.$)("F")," to the solution and repeat"]})]}),(0,r.tZ)(x.Z,{language:"typescript",sx:{mb:2},children:"\nwhile (true) {\n  // Find the best path\n  const allPaths = computePaths(lookahead)\n  const pathsSorted = allPaths.sort((pathA, pathB) =>\n    currentColor.addPath(pathA).distanceTo(endColor) -\n    currentColor.addPath(pathB).distanceTo(endColor)\n  )\n\n  // This assumes a stable sort so that the empty path is prioritized\n  const bestPath = pathsSorted[0]\n\n  // If no paths get us closer, stop\n  if (bestPath.length === 0) {\n    return fruits\n\n  // Otherwise, add the first fruit in the path to the list and continue\n  } else {\n    const bestFruit = bestPath[0]\n    fruits.push(bestFruit)\n    currentColor = currentColor.add(bestFruit)\n    currentDistance = currentColor.distanceTo(endColor)\n  }\n}\n          ".trim()}),(0,r.BX)(l.Z,{paragraph:!0,children:["With a big enough lookahead, the algorithm is able to momentarily step further away from the target color in order to get closer later. The algorithm implemented on the ",(0,r.tZ)($.C,{href:"/chocobo-color",children:"Chocobo Color page"})," is this algorithm with a lookahead of ",(0,v.$)("L = 3"),", which specifically admits the strategy of eating 3 fruits to increase/reduce all values by 5. This performs very well."]}),(0,r.BX)(l.Z,{paragraph:!0,children:["Lookahead also allows the algorithm to utilizing clamping, considering cases where the fruits no longer commute. For example, if the current color is ",(0,k.Z)(n,C.DX[1],"name")," ",(0,r.tZ)(B.Z,{inline:!0,stain:C.DX[1]})," and the target color is ",(0,k.Z)(n,C.DX[6],"name")," ",(0,r.tZ)(B.Z,{inline:!0,stain:C.DX[6]}),", then we need to decrease the RGB values as much as possible. Without any clamping, this can be done in 110 fruits. With clamping, it\u2019s possible to get as close with 97 fruits instead. It involves feeding a bunch of ",(0,k.Z)(n,C.DN[y.PO.XelphatolApple],"plural","singular")," first to max out the RGB\u2019s red value so that subsequent ",(0,k.Z)(n,C.DN[y.PO.XelphatolApple],"plural","singular")," will lower the average RGB value quicker. Unfortunately, lookaheads with ",(0,v.$)("L > 5")," quickly become infeasible, the benefits are small, and situations that can use it are rare."]}),(0,r.tZ)(E,{})]}),(0,r.BX)(w.Z,{title:"Optimality",children:[(0,r.BX)(l.Z,{paragraph:!0,children:["Fortunately, a lookahead of ",(0,v.$)("L = 3")," is enough to guarantee that the algorithm terminates with a color as close to the target color as possible (ignoring clamping). By feeding 2 fruits, any individual RGB value can be adjusted by ",(0,v.$)("\\pm10")," while leaving the other two values unaffected. This means that the color the algorithm ends up at cannot have coordinates that differ from the target color\u2019s by more than ",(0,v.$)("5"),". The same must be true of the optimal solution."]}),(0,r.BX)(l.Z,{paragraph:!0,children:["Let the solution the algorithm returns be ",(0,v.$)("\\operatorname{RGB(r, g, b)}"),". Focusing only on the red component, the optimal solution must have a red component of ",(0,v.$)("r-5"),", ",(0,v.$)("r"),", or ",(0,v.$)("r+5"),". Now consider the 27 points:"]}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,r.BX)(s.Z,{component:Z.Z,sx:{width:"auto",m:"auto"},children:[(0,r.tZ)(u.Z,{children:(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{}),(0,r.tZ)(m.Z,{}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("r-5")}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("r")}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("r+5")})]})}),(0,r.BX)(g.Z,{children:[(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",rowSpan:3,align:"center",children:(0,v.$)("g-5")}),(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b-5")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r-5, g-5, b-5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g-5, b-5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r+5, g-5, b-5)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r-5, g-5, b+0)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g-5, b+0)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+5, g-5, b+0)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b+5")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r-5, g-5, b+5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g-5, b+5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r+5, g-5, b+5)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",rowSpan:3,align:"center",children:(0,v.$)("g")}),(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b-5")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r-5, g+0, b-5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g+0, b-5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+5, g+0, b-5)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r-5, g+0, b+0)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r+0, g+0, b+0)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+5, g+0, b+0)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b+5")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r-5, g+0, b+5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g+0, b+5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+5, g+0, b+5)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",rowSpan:3,align:"center",children:(0,v.$)("g+5")}),(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b-5")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r-5, g+5, b-5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g+5, b-5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:T},children:(0,v.$)("(r+5, g+5, b-5)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r-5, g+5, b+0)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g+5, b+0)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+5, g+5, b+0)")})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:(0,v.$)("b+5")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r-5, g+5, b+5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+0, g+5, b+5)")}),(0,r.tZ)(m.Z,{align:"center",sx:{backgroundColor:O},children:(0,v.$)("(r+5, g+5, b+5)")})]})]})]})}),(0,r.BX)(l.Z,{paragraph:!0,children:["One of these points is the optimal solution, and all the points marked as red are impossible to reach due to parity (see the Error section below). Starting at ",(0,v.$)("(r, g, b)"),", we must show that the algorithm considers all the green points with a lookahead of ",(0,v.$)("L = 3"),". By symmetry, there are only 3 cases that need to be checked."]}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,r.BX)(s.Z,{component:Z.Z,sx:{width:"auto",m:"auto"},children:[(0,r.tZ)(u.Z,{children:(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{align:"center",children:"Target color"}),(0,r.tZ)(m.Z,{align:"center",children:"Solution"})]})}),(0,r.BX)(g.Z,{children:[(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("(r+0, g+0, b+0)")}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(l.Z,{children:"No fruits"})})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("(r+5, g+5, b+5)")}),(0,r.BX)(m.Z,{align:"center",children:[(0,r.tZ)(X.Z,{fruit:y.PO.DomanPlum}),(0,r.tZ)(X.Z,{fruit:y.PO.Valfruit}),(0,r.tZ)(X.Z,{fruit:y.PO.CieldalaesPineapple})]})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("(r+5, g+5, b-5)")}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(X.Z,{fruit:y.PO.CieldalaesPineapple})})]})]})]})}),(0,r.tZ)(l.Z,{paragraph:!0,children:"Thus the algorithm is optimal, in the sense that it returns the closest possible color without clamping."})]}),(0,r.BX)(w.Z,{title:"Error",children:[(0,r.BX)(l.Z,{paragraph:!0,children:["The algorithm can get us pretty close to the desired color, but it\u2019s not always possible to be exact. The two closest possible colors a chocobo can be are ",(0,k.Z)(n,C.DX[79],"name")," ",(0,r.tZ)(B.Z,{inline:!0,stain:C.DX[79]})," and ",(0,k.Z)(n,C.DX[81],"name")," ",(0,r.tZ)(B.Z,{inline:!0,stain:C.DX[81]}),". These two have a distance of ",(0,v.$)("9.434"),", so if we can guarantee an error of less than ",(0,v.$)("9.434 / 2 = 4.717"),", then the desired color will always be the closest color, but this is impossible to guarantee."]}),(0,r.BX)(l.Z,{paragraph:!0,children:["Feeding a fruit will always change the parity of the RGB values, i.e. odd \u2192 even or even \u2192 odd. If the target color is ",(0,v.$)("\\operatorname{RGB}(100, 100, 100)")," with all even values, and the current color is ",(0,v.$)("\\operatorname{RGB}(100, 100, 105)")," with 1 odd value, no sequence of fruits can get closer (ignoring clamping). Thus the maximum error is bounded below by ",(0,v.$)("5"),", and we cannot guarantee that the closest color is the desired color. The maximum error is actually ",(0,v.$)("5\\sqrt{5}/2 \\approx 5.59")," given by the vector ",(0,v.$)("(5, 2.5, 0)"),"."]}),(0,r.BX)(l.Z,{paragraph:!0,children:["A possible solution is to instead aim for some color that is near the desired color and far from other nearby colors, maximizing the likelihood that we end up at the desired color. The hope is that our final color ends up inside the ",(0,r.tZ)($.C,{href:"https://en.wikipedia.org/wiki/Voronoi_diagram",children:"Voronoi cell"})," of the desired color, so a sensible target would be the centroid of this region. In 2D, this may look like"]}),(0,r.BX)(c.Z,{component:"figure",mb:2,textAlign:"center",children:[(0,r.tZ)("img",{src:"/images/chocobo-color/voronoi-diagram.png"}),(0,r.tZ)("figcaption",{children:(0,r.tZ)(l.Z,{variant:"caption",children:"The dots are colors we want to achieve, and the crosses are alternative targets."})})]}),(0,r.tZ)(l.Z,{paragraph:!0,children:"This would allow more room for error, but I decided computing these targets would be too much work. It would also complicate recoloring chocobos. As long as the algorithm gets as close to the desired color as possible (ignoring clamping), it\u2019s sufficient. There are only two color combinations where the closest color does not lead to the desired color, and those have hardcoded solutions for now."}),(0,r.tZ)(d.Z,{sx:{mb:2},children:(0,r.tZ)(s.Z,{component:Z.Z,sx:{width:"auto",m:"auto"},children:(0,r.BX)(g.Z,{children:[(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:"Current color"}),(0,r.BX)(m.Z,{align:"center",children:[(0,k.Z)(n,C.DX[37],"name"),(0,r.tZ)("br",{}),(0,v.$)("(250, 198, 43)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{stain:C.DX[37]})}),(0,r.BX)(m.Z,{align:"center",children:[(0,k.Z)(n,C.DX[57],"name"),(0,r.tZ)("br",{}),(0,v.$)("(150, 189, 185)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{stain:C.DX[57]})})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:"Desired color"}),(0,r.BX)(m.Z,{align:"center",children:[(0,k.Z)(n,C.DX[79],"name"),(0,r.tZ)("br",{}),(0,v.$)("(50, 44, 59)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{stain:C.DX[79]})}),(0,r.BX)(m.Z,{align:"center",children:[(0,k.Z)(n,C.DX[79],"name"),(0,r.tZ)("br",{}),(0,v.$)("(50, 44, 59)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{stain:C.DX[79]})})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:"\u201cOptimal\u201d solution"}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("(55, 43, 58)")}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{color:new y.Il(55,43,58)})}),(0,r.tZ)(m.Z,{align:"center",children:(0,v.$)("(55, 44, 60)")}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{color:new y.Il(55,44,60)})})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:"Resultant color"}),(0,r.BX)(m.Z,{align:"center",children:[(0,k.Z)(n,C.DX[81],"name"),(0,r.tZ)("br",{}),(0,v.$)("(59, 42, 61)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{stain:C.DX[81]})}),(0,r.BX)(m.Z,{align:"center",children:[(0,k.Z)(n,C.DX[81],"name"),(0,r.tZ)("br",{}),(0,v.$)("(59, 42, 61)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{stain:C.DX[81]})})]}),(0,r.BX)(p.Z,{children:[(0,r.tZ)(m.Z,{component:"th",scope:"row",align:"center",children:"Adjusted solution"}),(0,r.BX)(m.Z,{align:"center",children:["Remove 1\xd7 ",(0,r.tZ)(X.Z,{fruit:y.PO.XelphatolApple,size:.8}),(0,r.tZ)("br",{}),(0,v.$)("(50, 48, 63)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{color:new y.Il(50,48,63)})}),(0,r.BX)(m.Z,{align:"center",children:["Add 1\xd7 ",(0,r.tZ)(X.Z,{fruit:y.PO.MamookPear,size:.8}),(0,r.tZ)("br",{}),(0,v.$)("(50, 49, 55)")]}),(0,r.tZ)(m.Z,{align:"center",children:(0,r.tZ)(B.Z,{color:new y.Il(50,49,55)})})]})]})})})]})]})}},7556:function(e,t,n){"use strict";var r=n(5944),o=(n(7294),n(2734)),i=n(5113),a=n(7561),l=n(6671),c=n(2538),s=n(8575),h=n(5801);a.Z.registerLanguage("javascript",c.Z),a.Z.registerLanguage("latex",s.Z),a.Z.registerLanguage("typescript",h.Z);t.Z=function(e){var t=e.language,n=e.sx,c=e.children,s=(0,o.Z)();return(0,r.tZ)(i.Z,{component:a.Z,variant:"outlined",language:t,style:"dark"===s.palette.mode?l.FE:l.bW,sx:n,children:c})}},3432:function(e,t,n){"use strict";n.d(t,{$:function(){return s},$$:function(){return h},Q:function(){return d}});var r=n(5944),o=n(7294),i=n(9104),a=!1;function l(){a||(a=!0,setTimeout((function(){"undefined"!==typeof MathJax&&MathJax.Hub.Queue(["Typeset",MathJax.Hub]),a=!1}),0))}var c=function(e){var t=e.math,n=e.displayMode,i=void 0!==n&&n;return(0,o.useEffect)(l,[t,i]),i?(0,r.tZ)("div",{children:"\\[".concat(t,"\\]")}):(0,r.tZ)("span",{children:"\\(".concat(t,"\\)")})},s=function(e){return(0,r.tZ)(i.Z,{children:(0,r.tZ)(c,{math:e})})},h=function(e){return(0,r.tZ)(i.Z,{children:(0,r.tZ)(c,{math:e,displayMode:!0})})},d=function(e){return(0,r.tZ)(i.Z,{children:(0,r.tZ)("div",{style:{display:"none"},children:(0,r.tZ)(c,{math:"\\require{".concat(e,"}")})})})}}},function(e){e.O(0,[962,325,477,617,774,888,179],(function(){return t=7238,e(e.s=t);var t}));var t=e.O();_N_E=t}]);